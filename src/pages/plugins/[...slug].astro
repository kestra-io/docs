---
export const prerender = false
import { getCollection } from "astro:content";
import Layout from "../../components/layout.astro";
import PluginSidebar from "~/components/plugins/PluginSidebar.vue";
import Breadcrumb from "~/components/layout/Breadcrumb.vue";
import NavToc from "~/components/docs/NavToc.vue";
import RelatedBlueprints from "~/components/plugins/RelatedBlueprints.vue";
import RelatedBlogs from "~/components/plugins/RelatedBlogs.vue";
import SimilarPlugins from "~/components/plugins/SimilarPlugins.vue";
import PluginMDC from "~/components/plugins/PluginMDC.vue";
import PluginsMDCRender from "~/components/plugins/PluginsMDCRender.vue";
import PluginVideos from "~/components/plugins/PluginVideos.vue";
import { $fetch } from "~/utils/fetch";
import { generatePageNames, recursivePages, type NavItem } from "~/utils/navigation";
import { filterPluginsWithoutDeprecated, isEntryAPluginElementPredicate, slugify, subGroupName, type Plugin, type PluginMetadata } from "@kestra-io/ui-libs";
import { formatElementName, formatElementType, getBlueprintsHeading, getPluginTitle } from "~/utils/pluginUtils";
import type { ReleaseInfo } from "../../../server/api/github-releases";

const splitRouteSlug = Astro.params.slug?.split("/") ?? [];
const pathname = new URL(Astro.request.url).pathname;

interface PluginPageParams {
    body: {
        group: string;
        plugins: Plugin[];
        toc: {links: any[]};
    };
    rightBar?: boolean;
    title?: string;
    description?: string;
    longDescription?: string;
    error?: boolean;
    message?: string;
    editLink?: boolean;
    extension?: string;
    stem?: string;
}

const pluginName = splitRouteSlug[0];

const githubReleaseRepo = (() => {
    const name = pluginName ?? "";
    // because core plugin is part of kestra repo
    if (name === "core") {
        return "kestra";
    }
        // because plugin-jdbc is the parent for many subgroups in same repo.
    if (name.startsWith("plugin-jdbc-") || name === "plugin-jdbc") {
        return "plugin-jdbc";
    }
    return name;
})();

const githubReleasesUrl = `https://github.com/kestra-io/${githubReleaseRepo}/releases`

// FIXME: import function instead of fetch
const navigation = await $fetch<[NavItem]>("/api/plugins?type=navigation");
const sidebarPluginData = await $fetch<PluginPageParams>(`/api/plugins?page=${splitRouteSlug[0]}&type=plugin`);
const page = await $fetch<PluginPageParams>(`/api/plugins?page=${splitRouteSlug[0]}&type=plugin`);
const subGroupsIcons = await $fetch<Record<string, string>>("/api/plugins?type=subGroupsIcons");
const elementIcons = await $fetch<Record<string, string>>(`/api/plugins?page=${pluginName}&type=elementsIcons`);
const {countByPlugins: blueprintCounts} = await $fetch<{
            countByPlugins: Record<string, number>;
        }>('/api/blueprint?counts=true')
const allPlugins = await $fetch<Plugin[]>(`/api/plugins?type=allPlugins`);
const allPluginMetadata = await $fetch<PluginMetadata[]>(`/api/plugins?type=metadata`);
const githubVersions = await $fetch<{versions: ReleaseInfo[]}>(`/api/github-releases?repo=${githubReleaseRepo}`);

const blogs = await getCollection('blogs');
const relatedBlogs = blogs
    .filter(b => b.data.plugins?.includes(pluginName))
    .sort((a, b) => {
        return a.data.date > b.data.date ? 1 : -1;
    });

const pageList = recursivePages(navigation[0]);
const pageNames = generatePageNames(navigation[0]);

const pluginType = (() => {
    const lastSegment = splitRouteSlug[splitRouteSlug.length - 1];
    if (!lastSegment || !lastSegment.includes(".")) return undefined;

    const parts = lastSegment.replace(/.md$/, "").split(".");
    return `${parts.slice(0, -1).join(".")}.${
        pageNames?.[pathname] ?? parts[parts.length - 1]
    }`})();

const pluginsWithoutDeprecated =
        filterPluginsWithoutDeprecated(
            pluginType
                ? sidebarPluginData?.body?.plugins ?? []
                : page?.body?.plugins ?? []
        )

const rootPlugin = pluginsWithoutDeprecated?.find((p: Plugin) => p.subGroup === undefined)

const maybeSubGroup = splitRouteSlug[1];
const subGroup = maybeSubGroup?.includes(".") ? undefined : maybeSubGroup;
const currentSubgroupPlugin = (!subGroup || pluginType) ? undefined : pluginsWithoutDeprecated?.find(p => {
            const subgroupLastSegment = p.subGroup?.split(".").pop();
            const possibleSubgroupMatches = [
                slugify(subGroupName(p)),
                subgroupLastSegment,
                slugify(subgroupLastSegment ?? "")
            ];
            return possibleSubgroupMatches.includes(subGroup);
        });

const metadataMap = {} as Record<string, any>;
const headingTitle = pluginType
    ? formatElementName(pluginType)
    : (rootPlugin
        ? getPluginTitle(
            currentSubgroupPlugin ?? rootPlugin,
            metadataMap
        )
        : undefined
    ) ?? pluginName;

const pageNamesHeading = {
        ...(pageNames ?? {}),
        [pathname]: headingTitle,
        [`/plugins/${pluginName}`]: getPluginTitle(
            rootPlugin!,
            metadataMap
        ) ?? pluginName
    }

const currentPageIcon = (() => {
        const icons = subGroupsIcons;
        if (!icons) return undefined;

        let icon;

        if (pluginType) {
            icon = elementIcons?.[pluginType];
        } else if (!subGroup && page?.body?.group) {
            icon = icons[page.body.group];
        } else if (currentSubgroupPlugin) {
            icon = icons[currentSubgroupPlugin.subGroup ?? ""] ?? icons[currentSubgroupPlugin.group];
        }

        return icon ? `data:image/svg+xml;base64,${icon}` : undefined;
    })();

const generateTocForPluginElements = (wrapper: Plugin) =>
        Object.entries(wrapper)
            .filter(([key]) => isEntryAPluginElementPredicate(key, wrapper[key as keyof Plugin]))
            .map(([key]) => {
                const formattedElementType = key.replace(/[A-Z]/g, match => ` ${match}`);
                return {
                    id: `section-${slugify(formattedElementType)}`,
                    depth: 3,
                    text: formatElementType(key)
                };
            });

 /**
  * currentPluginMetadata provides the raw array of metadata,
  * while currentPageMetadata filters it down to the exact metadata for the page being viewed.
  */
const currentPluginMetadata = (() => {
    const subgroupId = currentSubgroupPlugin?.subGroup ?? currentSubgroupPlugin?.group;
    const rootGroupId = rootPlugin?.group ?? pluginName;

    if (subgroupId) {
        const found = allPluginMetadata?.find(m => m.group === subgroupId);
        return found ? [found] : [];
    }

    if (rootGroupId) {
        return allPluginMetadata?.filter(m => m.group && (m.group === rootGroupId || m.group.startsWith(rootGroupId + "."))) ?? [];
    }

    return [];
})();

const currentPluginVideos = (() => {
        const meta = currentPluginMetadata;
        if (!meta) return [];

        const subgroupId = currentSubgroupPlugin?.subGroup ?? currentSubgroupPlugin?.group;
        const rootGroup = rootPlugin?.group;
        const entries = Array.isArray(meta) ? meta : [meta];

        return entries
            .filter(m => {
                if (!m) return false;

                if (subgroupId) {
                    return typeof m.group === "string" &&
                        (m.group === subgroupId || m.group.startsWith(subgroupId + "."));
                } else if (m.name === pluginName) {
                    return true;
                }

                return typeof m.group === "string" &&
                    (m.group === rootGroup || m.group?.startsWith(rootGroup ?? ""));
            })
            .flatMap(m => m?.videos ?? [])
            .filter(Boolean);
    })();

const blueprintsSectionHeading = getBlueprintsHeading(
    pluginName,
    rootPlugin,
    subGroup,
    pluginType,
)

const currentPluginCategories = (() => {
    const subgroupCats = currentSubgroupPlugin?.categories;
    const pluginCats = rootPlugin?.categories;
    return subGroup === undefined
        ? pluginCats ?? []
        : (subgroupCats?.length ? subgroupCats : pluginCats ?? []);
})();

function makeTOC(){
    const pluginToc = (() => {
        if (!rootPlugin) return [];

        if (subGroup && currentSubgroupPlugin) {
            return generateTocForPluginElements(currentSubgroupPlugin);
        }

        if (!subGroup && !pluginType) {
            const subGroups = pluginsWithoutDeprecated?.filter(p => p.subGroup) ?? [];
            return subGroups.length
                ? subGroups.map(sub => ({
                    id: slugify(subGroupName(sub)),
                    depth: 3,
                    text: subGroupName(sub)
                }))
                : generateTocForPluginElements(rootPlugin);
        }

        return [];
    })();

    const subgroupBlueprintCounts = (() => {
        const result: Record<string, number> = {};

        pluginsWithoutDeprecated?.forEach((subgroupWrapper) => {
            const subgroupKey = subgroupWrapper.subGroup;
            if (subgroupKey !== undefined) {
                const formattedKey = `${subgroupWrapper.group ?? subgroupWrapper.name}-${slugify(subGroupName(subgroupWrapper))}`;
                result[formattedKey] = blueprintCounts?.[subgroupKey] ?? 0;
            }
        });

        return result;
    })();

    const baseTocLinks = pluginType
            ? page.body.toc?.links?.map(l => ({...l, children: undefined})) ?? []
            : page.body?.toc ? [] : pluginToc;

        const hasBlueprints = pluginType
            ? blueprintCounts?.[pluginType] > 0
            : subGroup
                ? subgroupBlueprintCounts?.[
                    `${rootPlugin?.group ?? pluginName}-${subGroup}`
                ] > 0
                : blueprintCounts?.[
                    rootPlugin?.group ?? pluginName
                ] > 0;

        const tocLinks = [
            ...baseTocLinks,
            ...(pluginType === undefined && rootPlugin?.longDescription
                ? [{id: "how-to-use-this-plugin", depth: 2, text: "How to use this plugin"}]
                : []
            ),
            ...(pluginType === undefined && currentPluginVideos?.length > 0
                ? [{id: "see-it-in-action", depth: 3, text: "See it in action"}]
                : []
            ),
            ...(hasBlueprints && blueprintsSectionHeading?.id && blueprintsSectionHeading?.text
                ? [{id: blueprintsSectionHeading.id, depth: 3, text: blueprintsSectionHeading.text}]
                : []
            ),
            ...(pluginType === undefined && subGroup === undefined && relatedBlogs?.length > 0
                ? [{id: "latest-blog-posts", depth: 3, text: "Latest Blog Posts"}]
                : []
            ),
            ...(allPlugins?.some(p => p.name !== pluginName && p.categories?.some(cat => currentPluginCategories?.includes(cat))) ?? false
                ? [{
                    id: "more-plugins-in-this-category",
                    depth: 3,
                    text: "More Plugins in this Category"
                }]
                : []
            )
        ];

        return tocLinks
}

const pageWithToc = {
            ...page,
            body: {
                ...page.body,
                toc: {
                    links: makeTOC()
                }
            }
        };

const subgroupBlueprintCounts = (() => {
        const result: Record<string, number> = {};

        pluginsWithoutDeprecated?.forEach((subgroupWrapper) => {
            const subgroupKey = subgroupWrapper.subGroup;
            if (subgroupKey !== undefined) {
                const formattedKey = `${subgroupWrapper.group ?? subgroupWrapper.name}-${slugify(subGroupName(subgroupWrapper))}`;
                result[formattedKey] = blueprintCounts?.[subgroupKey] ?? 0;
            }
        });

        return result;
    })();

const elementTitle = (() => Object.fromEntries(
        (pluginsWithoutDeprecated ?? []).flatMap(p => (Object.entries(p) as [string, {title?: string, cls: string}[]][])
            .filter(([k, v]) => isEntryAPluginElementPredicate(k, v))
            .flatMap(([_, els]) => (els)
                .filter(el => el?.title)
                .map(el => [el.cls, {title: el.title}])
            )
        ).filter(([_, v]) => typeof v === "object" && Boolean(v?.title))
    ))()
---

<Layout>
    <div class="container-fluid bd-gutter bd-layout">
    <PluginSidebar
      pluginWrapper={rootPlugin}
      pluginsWithoutDeprecated={pluginsWithoutDeprecated}
      pluginName={pluginName}
      title={headingTitle}
      routeParts={splitRouteSlug}
    />
    <article
      class="bd-main order-1"
      class:list={[{ full: page?.rightBar === false }]}
    >
      <div class="bd-title">
        <Breadcrumb slug={pathname} {pageList} pageNames={pageNamesHeading} />
        {
          page && (
            <h1 class="py-0 title">
              {currentPageIcon && (
                <div class="pageIcon">
                  <NuxtImg
                    src={currentPageIcon}
                    alt={headingTitle}
                    loading="lazy"
                    format="webp"
                    quality="80"
                    densities="x1 x2"
                    class="blurred-bg"
                  />
                  <NuxtImg
                    src={currentPageIcon}
                    alt={headingTitle}
                    width="80"
                    height="80"
                    loading="lazy"
                    format="webp"
                    quality="80"
                    densities="x1 x2"
                    class="page-icon"
                  />
                </div>
              )}
              <div class="title-content d-flex flex-column justify-space-between w-100">
                <div class="d-flex align-items-center flex-wrap gap-3">
                  <span>{headingTitle}</span>
                  <img
                    src="/landing/plugins/certified.svg"
                    alt="Certified"
                    class="mt-1"
                  />
                </div>
                {(pluginType ? page?.title : page?.description) && (
                  <PluginsMDCRender
                    routePath={pathname}
                    page={page}
                    pluginName={pluginName ?? '<plugin>'}
                    pluginType={pluginType}
                    plugins={pluginsWithoutDeprecated}
                    icons={subGroupsIcons}
                    subGroup={subGroup}
                    client:idle
                  />
                )}
              </div>
              {rootPlugin?.license && (
                <div class="title-actions d-flex flex-column gap-2 ps-4">
                  <span class="btn enterprise-badge">Enterprise Edition</span>
                  <a
                    href="/demo"
                    class="btn btn-primary"
                    target="_blank"
                  >
                    Talk to us
                  </a>
                </div>
              )}
            </h1>
          )
        }
      </div>

      {
        pageWithToc && (
          <PluginMDC
            {page}
            plugin-type={pluginType}
            icons={subGroupsIcons}
            pluginsWithoutDeprecated={pluginsWithoutDeprecated}
            pluginName={pluginName}
            subGroup={subGroup}
            routePath={pathname}
            subgroupBlueprintCounts={subgroupBlueprintCounts}
            metadataMap={metadataMap}
            schemas={elementTitle}
          />
        )
      }

      {
        pluginType === undefined && currentPluginVideos?.length > 0 && (
          <PluginVideos videos={currentPluginVideos} />
        )
      }

      <RelatedBlueprints
        pluginName={pluginName}
        pluginWrapper={rootPlugin}
        currentSubgroupPlugin={currentSubgroupPlugin}
        subGroupName={currentSubgroupPlugin
          ? slugify(subGroupName(currentSubgroupPlugin))
          : subGroup}
        pluginType={pluginType}
        customId={blueprintsSectionHeading?.id}
      />

      {
        pluginType === undefined &&
          subGroup === undefined &&
          relatedBlogs &&
          relatedBlogs.length > 0 && <RelatedBlogs posts={relatedBlogs.map(p => ({
            ...p.data,
            path: p.id,
            date: p.data.date.toISOString()
        }))} />
      }

      {
        currentPluginCategories?.length > 0 && (
          <SimilarPlugins
            allPlugins={allPlugins}
            currentPluginName={pluginName}
            currentCategories={currentPluginCategories}
            icons={subGroupsIcons}
            metadataMap={metadataMap}
          />
        )
      }
    </article>
    <NavToc
      rate-helpful={true}
      links={page.body.toc?.links}
      editLink={page.editLink};
      extension={page.extension};
      stem={page.stem}
      version={githubVersions}
      releasesUrl={githubReleasesUrl}
      categories={currentPluginCategories}
      metadata={currentPluginMetadata}
      capitalize
      class="right-sidebar"
    />
  </div>
</Layout>