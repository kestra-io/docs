---
title: Kestra 0.17.0 brings a lightning-fast Code Editor, Autocompletion, improved Git sync, and Real-time Event Triggers ‚ö°Ô∏è
description: Get to know our new powerful code editor, autocompletion for all templated expressions, more flexible Git integration, real-time event processing capabilities, a new WaitFor task and inputs to a manual approval process. All this and more in Kestra 0.17.0!
date: 2024-06-04T13:00:00
category: News & Products Updates
author:
  name: Anna Geller
  image: ageller
image: /blogs/2024-06-04-release-0-17.png
---

We're excited to announce Kestra 0.17.0. This release focuses on developer productivity and performance, including the following highlights:
- New **Code Editor** that unifies the editing experience for Namespace Files and Flows
- **Autocompletion** for all templated expressions in both Code Editor and low-code UI forms
- New **Git integration** now syncs flows and namespace files separately giving you more control over your Git workflows
- **Real-time Event Triggers** let you react to events as they happen so you can automate your business processes in real-time
- Improved **orchestration capabilities** with the `WaitFor` task allowing you to continuously execute a list of tasks until a specific condition is met
- With the addition of inputs to a **Pause** task, you can now pause a workflow execution and resume it later with custom input values, significantly improving **human-in-the-loop processes**
- Improved **naming** conventions for better consistency ‚Äî a.o. `taskDefaults` are now `pluginDefaults` and the critical HTTP tasks are now part of the core plugin.

Let's dive in!

## New Code Editor üíª

We're introducing a brand-new, lightning-fast [Code Editor](https://github.com/kestra-io/kestra/pull/3568) which significantly improves the development experience as compared to our previous VS Code-based solution. The new editor is now the default editor for both Namespace Files and Flows, offering a unified development experience.

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/o-d-GaXUiKQ?si=uOWKqdj51-GCA0jS" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


### Why a New Code Editor?

Initially, our Namespace Files Editor was built on top of the FOSS version of VS Code to leverage its extensive ecosystem. However, feedback from our community highlighted several challenges with this approach:

1. **Difficult Onboarding**: the embedded VS Code application was slow to load and difficult to get started with for new users.
2. **Limited Extensions**: many popular VS Code extensions such as GitHub Copilot are unfortunately not available in the FOSS version, significantly limiting its utility.
3. **UX Constraints**: every interaction between the UI and VS Code had to be performed via an extension, making it impossible for us to create a truly seamless user experience.
4. **Design Constraints**: VS Code didn't allow us to implement a cohesive, aesthetically pleasing design aligned with our quality standards.

### Value of the new Code Editor

The new Code Editor addresses all these pain points and offers a host of benefits:

1. **Better Performance**: it loads lightning-fast ‚ö°Ô∏è
2. **Streamlined Experience**: one Editor to rule them all - no need to switch between different editors for Namespace Files and Flows.
3. **Improved Navigation**: the new editor sidebar now displays only Namespace Files without mixing them with the flow code.
4. **Intuitive Design**: the look-and-feel is more enjoyable, visually appealing and easier to get started with.
5. **Seamless Integration**: a much better integration with the rest of the UI, e.g. you can now easily edit the flow code from its Execution's page in a way that feels natural and intuitive.

In short, the new editor offers a fast, unified and user-friendly editing experience.

---

## Autocompletion ‚òëÔ∏è

Along with the new Code Editor, we've added [Autocompletion](https://github.com/kestra-io/kestra/issues/3331) for all templated expressions in the editor. This feature will help you write flows faster by suggesting variables, inputs, outputs and other expressions as you type.

### Subflow Autocompletion
When you use the Subflow task, you'll [now](https://github.com/kestra-io/kestra/pull/3581) also get [autocompletion for subflows](https://github.com/kestra-io/kestra/issues/2473). Just add the subflow task, and start typing the namespace name to see the suggestions for the namespace and flow names and their inputs.

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/VOF4L8QE6vg?si=zm5m29qqeawjx6fe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

### Print Context for Debugging
Related to **Autocompletion**, we've added a `printContext()` function for debugging purposes. This [new function](https://github.com/kestra-io/kestra/issues/3537) will print the full Execution context, including all variables, inputs, outputs, and other execution metadata.

---

## New improved Git tasks üßë‚Äçüíª

With the release of Kestra 0.17.0, we are also [introducing](https://github.com/kestra-io/plugin-git/issues/56) a fully redesigned Version Control [integration](https://github.com/kestra-io/plugin-git/issues/57), offering more flexibility as compared to the previous Git tasks. Here's a list of the new tasks:
- **PushFlows**: commit and push saved flows to a Git repository.
- **SyncFlows**: sync flows from a Git branch to a Kestra namespace.
- **PushNamespaceFiles**: commit and push namespace files to a Git repository.
- **SyncNamespaceFiles**: sync namespace files from a Git branch to a Kestra namespace.

### Capabilities of the New Git Tasks

1. **Simplified Namespace Management**: nested namespaces now work in the same way as you would expect it from local folders, bringing an intuitive way to structure and organize your flows.
2. **Selective Git Pushes**: the new tasks give you more control over what gets committed, e.g. you can now push only one or more specific flows to your chosen Git directories and branches.
3. **Seamlessly Integrated**: you can combine the `PushFlows` and `SyncFlows` tasks together to create a complete Git workflow: push your flows from a development environment to a Git repository and then sync them back to your Kestra environment after they've been reviewed and merged to a production branch.
4. **Easily Testable**: you can validate your Git workflows in a dry-run mode before committing and pushing your changes.

### PushFlows Task

The PushFlows task allows you to easily commit and push your saved flows to a Git repository. Check the [following documentation](https://kestra.io/docs/how-to-guides/pushflows) and the video demonstration below to learn more about how you can use this task to automate your Git workflow.

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/OPlNKQZFeho?si=ZvRQfLjnhjDYk1qN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


### SyncFlows Task

The SyncFlows task automatically checks for changes in your Git branch and deploys them to your Kestra namespace(s), keeping your Kestra environment in sync with your Git repository.

It eliminates the need for CI/CD pipelines ‚Äî you can use it to sync flows from Git to Kestra on a regular cadence (e.g. an hourly or daily `Schedule` trigger) or whenever changes are merged into a specified Git branch (e.g. a `Webhook` trigger).

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/YbIuqYWLrpA?si=OChhyF1Lz6j8ybGX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

**Example: Scheduled Sync**

Sync flows from a Git repository to a Kestra `git` namespace every hour:

```yaml
id: sync_flows_from_git
namespace: system

tasks:
  - id: git
    type: io.kestra.plugin.git.SyncFlows
    gitDirectory: flows
    targetNamespace: git
    includeChildNamespaces: true # optional; by default, it's set to false to allow explicit definition
    delete: true # optional; by default, it's set to false to avoid destructive behavior
    url: https://github.com/anna-geller/flows
    branch: develop
    username: anna-geller
    password: "{{ secret('GITHUB_ACCESS_TOKEN') }}"
    dryRun: false

triggers:
  - id: hourly
    type: io.kestra.plugin.core.trigger.Schedule
    cron: "0 * * * *"
```


The `PushNamespaceFiles` and `SyncNamespaceFiles` tasks work analogically to the `PushFlows` and `SyncFlows` tasks, but applied to [namespace files](../docs/08.developer-guide/03.namespace-files.md). Watch the videos below to see how you can use these tasks to manage your namespace files with Git.

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/-bEnwR5t7VI?si=wNG-fvtuavvVkSmF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/AbxaDtINcr8?si=68--VkN_sIcuwm5K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

These new tasks will supercharge your Git workflows, making it easier to version control your flows and namespace files.

---

## Realtime triggers ‚ö°Ô∏è

Kestra 0.17.0 introduces a concept of [Real-time Event Triggers](https://github.com/kestra-io/kestra/pull/3355) allowing you to react to events as they happen with millisecond latency.

### Why Real-time Triggers?
Kestra has a concept of [triggers](../docs/04.workflow-components/07.triggers.md) that can listen to external events and start a workflow execution when the event occurs. Most of these triggers poll external systems for new events at regular intervals e.g. every second. While this works well for most use cases, business-critical workflows require reacting to events as they happen with **millisecond latency**. This is where Real-time Triggers come into play.

| Criteria             | Trigger                                                               | Real-time Trigger                                                                               |
|----------------------|-----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **Implementation**   | Micro-batch                                                           | Real-time                                                                                       |
| **Event Processing** | Batch-process all events received until the poll interval has elapsed | Process each event immediately as it happens                                                    |
| **Latency**          | Second(s) or minute(s)                                                | Millisecond(s)                                                                                  |
| **Execution Model**  | Each execution can process one or many events                         | Each execution can process exactly one event                                                    |
| **Data Handling**    | Store all received events in a file                                   | Store each event in a raw format                                                                |
| **Output format**    | URI of a file in internal storage                                     | Raw data of the event payload and related metadata                                              |
| **Application**      | Data applications processing data in batch                            | Business-critical operations reacting to events in real-time                                    |
| **Use cases**        | Data orchestration for analytics and building data products           | Process and microservice orchestration (real-time updates, anomaly detection, order processing) |


Real-time triggers listen to events in real-time and start a workflow execution as soon as:
- a new message is published to a [Kafka topic](/plugins/plugin-kafka/triggers/io.kestra.plugin.kafka.realtimetrigger)
- a new message is published to an [AMQP queue](/plugins/plugin-amqp/triggers/io.kestra.plugin.amqp.realtimetrigger)
- a new message arrives in AWS SQS or [Google Pub/Sub](plugins/plugin-gcp/triggers/pubsub/io.kestra.plugin.gcp.pubsub.realtimetrigger)
- a new key is added to a [Redis list](/plugins/plugin-redis/triggers/io.kestra.plugin.redis.realtimetriggerlist)
- ...and many more.

With this new feature, you can orchestrate business-critical processes and microservices in real-time. This covers scenarios such as fraud/anomaly detection, order processing, real-time predictions or recommendations, reacting to stock price changes, shipping and delivery notifications, and many more.

### How to Use Real-time Triggers

To use Real-time Triggers, you need to configure the trigger in your workflow YAML file. Here's an example of a Real-time Trigger listening to new messages in a Kafka topic and triggering exactly one workflow execution in real-time for each received message:

```yaml
id: kafka
namespace: myteam

tasks:
  - id: log
    type: io.kestra.plugin.core.log.Log
    message: "{{ trigger }}"

triggers:
  - id: realtime_trigger
    type: io.kestra.plugin.kafka.RealtimeTrigger
    topic: test_kestra
    properties:
      bootstrap.servers: localhost:9092
    serdeProperties:
      schema.registry.url: http://localhost:8085
    keyDeserializer: STRING
    valueDeserializer: AVRO
    groupId: kafkaConsumerGroupId
```

---

## Human in the loop with Pause task

The Pause task now supports `onResume` [inputs](https://github.com/kestra-io/kestra/issues/1581), allowing you to pause a workflow execution and resume it later with custom input values. This is particularly useful for human-in-the-loop processes where you need to collect additional information from a user before proceeding with the workflow.

### Human-in-the-loop Workflow for Interactive AI Applications

An increasingly common use case for the manual approval processes is in AI applications where human intervention is required to validate the AI's output. The video below demonstrates how you can automatically pause a workflow execution until the user resumes it with custom input values.

<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ohEA2eYaQrc?si=QKDHq6swDLJiFibL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


### Manual Approval Process
Below, you can see an example of a workflow that sends a Slack message requesting approval for a vacation request to a manager. The workflow execution is paused until the manager resumes it with custom input values. Those input values indicate whether the request was approved and the reason for the decision.

```yaml
id: vacation_approval_process
namespace: dev

inputs:
  - id: request.name
    type: STRING
    defaults: Rick Astley

  - id: request.start_date
    type: DATE
    defaults: 2024-07-01

  - id: request.end_date
    type: DATE
    defaults: 2024-07-07

  - id: slack_webhook_uri
    type: URI
    defaults: https://reqres.in/api/slack

tasks:
  - id: sendApprovalRequest
    type: io.kestra.plugin.notifications.slack.SlackIncomingWebhook
    url: "{{ inputs.slack_webhook_uri }}"
    payload: |
      {
        "channel": "#vacation",
        "text": "Validate holiday request for {{ inputs.request.name }}. To approve the request, click on the `Resume` button here http://localhost:28080/ui/executions/{{flow.namespace}}/{{flow.id}}/{{execution.id}}"
      }

  - id: waitForApproval
    type: io.kestra.plugin.core.flow.Pause
    onResume:
      - id: approved
        description: Approve the request?
        type: BOOLEAN
        defaults: true
      - id: reason
        description: Reason for approval or rejection?
        type: STRING
        defaults: Approved

  - id: approve
    type: io.kestra.plugin.core.http.Request
    uri: https://reqres.in/api/products
    method: POST
    contentType: application/json
    body: "{{ inputs.request }}"

  - id: log
    type: io.kestra.plugin.core.log.Log
    message: Status is {{ outputs.waitForApproval.onResume.reason }}. Process finished with {{ outputs.approve.body }}
```

When you click on the `Resume` button in the UI, you will be prompted to provide the approval status and the reason for their decision. The workflow will then continue with the provided input values.

![pause_resume_1](/blogs/2024-06-04-release-0-17/pause_resume_1.png)

After the Execution has been resumed, any downstream task can access the `onResume` inputs using the `outputs` of the `Pause` task:

![pause_resume_2](/blogs/2024-06-04-release-0-17/pause_resume_2.png)


::alert{type="info"}
For more examples of how to use the Manual Approval pattern, check the [Pause and Resume](../docs/15.how-to-guides/parallel-vs-sequential.md) guide.
::

---

### The new `WaitFor` orchestration pattern

Many workflows require performing some action until a certain condition is met, or waiting for a specific condition to be met before proceeding with the next tasks. Common use cases include:

1. **Blocking Calls for Job Status**: to manage long-running jobs or external processes, you need to periodically check the status of these jobs, effectively blocking the next task runs until the job is completed.
2. **Dynamic Conditions from External APIs**: workflows frequently depend on data or conditions retrieved from external APIs. You may need to poll these APIs until specific conditions are met, such as waiting for a dataset to be updated, a transaction to be confirmed, or a resource to become available.
3. **Scraping APIs and Webpages**: when extracting data from APIs or webpages, the total number of pages or data size might not be known upfront. You might need to repeatedly fetch data until all pages have been scraped or a termination condition (like an empty response or a specific flag) is encountered.
4. **Waiting for Custom Events**: to synchronize with external events, such as file uploads, database triggers, or user actions, Kestra supports triggers as a primary solution. However, often polling custom events/systems for status might be more involved, requiring patterns such as [while-loops](https://github.com/kestra-io/kestra/issues/3024) to wait for custom events before starting specific task runs.

To accommodate these use cases, Kestra 0.17.0 introduces the [WaitFor](https://github.com/kestra-io/kestra/pull/3652) task that will run a list of tasks repeatedly (every `checkFrequency` interval) until the expected condition is met. This task will create a separate task run attempt within each loop iteration and will mark the Execution as Paused during the "wait" period (the time between loop iterations).

Let's see it in action!

The following example demonstrates a simple counter that loops until the counter reaches 10. The loop will run every 10 milliseconds until the counter reaches 10. The `Log` task will print the current iteration value in the logs.

```yaml
id: simple_counter
namespace: dev

tasks:
  - id: loop_until_10
    type: io.kestra.plugin.core.flow.WaitFor
    condition: "{{ outputs.loop_until_10.iterationCount < 10 }}"
    tasks:
      - id: log_iteration
        type: io.kestra.plugin.core.log.Log
        message: "Current iteration: {{ outputs.loop_until_10.iterationCount }}"
    checkFrequency:
      interval: PT0.01S
      maxDuration: PT30S
```

Now let's look at a more complex example where we use the `WaitFor` task to poll an external API for a job status. The workflow will repeatedly call the API every second until the job status is `finished`. The `Log` task will print a message when the job is finished.

```yaml
id: job_status
namespace: dev

tasks:
  - id: block_until_finished
    type: io.kestra.plugin.core.flow.WaitFor
    # replace with the actual condition e.g. {{ outputs.poll.body.status != 'finished' }}
    condition: "{{ outputs.poll.code != 200 }}"
    tasks:
      - id: poll
        type: io.kestra.plugin.core.http.Request
        uri: https://reqres.in/api/job-status
        method: GET
        contentType: application/json
    checkFrequency:
      interval: PT1S
      maxDuration: PT90S

  - id: continue
    type: io.kestra.plugin.core.log.Log
    message: the job finished, continuing downstream tasks!
```


---

## UI enhancements üìä

### New Getting-Started Experience

We've revamped the [Guided Tour](https://github.com/kestra-io/kestra/pull/3804) to help new users get started with Kestra. The new onboarding flow now allows you to choose the use case you're interested in and guides you through the process of creating your first flow.

As they say, a picture is worth a thousand words, so check out the new Getting Started experience in the following video demo:

TODO

### Improved Settings page
The Settings page has a [new structure](https://github.com/kestra-io/kestra/issues/1947) to make it easier to navigate and find the settings you need. The settings are now grouped into **Theme Preferences**, **Date and Time Preferences** as well as the **Main Configuration** settings.

![ui_settings](/blogs/2024-06-04-release-0-17/ui_settings.png)

### New Plugin Catalog

The new plugin catalog shows all plugins available in your Kestra instance. You can search for any plugin category e.g. AWS, as well as for a specific plugin subgroup e.g. S3. Once you click on a plugin, you'll be redirected to a full documentation page with all the details you need to start using it.

![ui_plugins](/blogs/2024-06-04-release-0-17/ui_plugins.png)

---

## Enhancements to the core ü´∂

### Java 21
Kestra [now runs](https://github.com/kestra-io/kestra/issues/3234) on Java 21. If you use [Standalone Server](https://kestra.io/docs/installation/standalone-server), make sure to update your Java version to 21 before upgrading to Kestra 0.17.0 and beyond.

### Array input

So far, the `JSON` input type allowed you to pass an array of objects. However, the contents of the array could be of any type and the only way to add validation to them would be to use [nested inputs](../docs/04.workflow-components/05.inputs.md#nested-inputs).

Kestra 0.17.0 adds a new `ARRAY` input type that allows you to specify the type of the array elements using the `itemType` property.

This [enhancement](https://github.com/kestra-io/kestra/issues/771) is particularly useful when you want the end user triggering the workflow to provide multiple values of a specific type, e.g. a list of integers, strings, booleans, datetimes, etc. You can provide the default values as a JSON array or as a YAML list ‚Äî both are supported.

```yaml
id: array_demo
namespace: dev

inputs:
  - id: my_numbers_json_list
    type: ARRAY
    itemType: INT
    defaults: [1, 2, 3]

  - id: my_numbers_yaml_list
    type: ARRAY
    itemType: INT
    defaults:
      - 1
      - 2
      - 3

tasks:
  - id: print_status
    type: io.kestra.plugin.core.log.Log
    message: received inputs {{ inputs }}
```

::alert{type="info"}
For more details on the `ARRAY` input type, check out the [Inputs](../docs/04.workflow-components/index.md) documentation.
::

### Renaming
We've refactored several core abstractions to ensure consistent and intuitive naming. Many core tasks, triggers and conditions have been renamed. For example, `taskDefaults` are now `pluginDefaults` to highlight that you can set default values for all plugins (_including triggers, task runners and more_), not just tasks.

All of these are **non-breaking changes** as we leverage **aliases** for backward compatibility. You will see a friendly warning in the UI code editor if you use the old names.

![renamed-core-plugins](/docs/migration-guide/renamed-core-plugins.png)

It's worth taking a couple of minutes to rename those in your flows to future-proof your code.

::alert{type="info"}
Check the [Renamed Core Plugins](../docs/11.migration-guide/renamed-core-plugins.md) Migration Guide for a full list of renamed tasks, triggers and conditions.
::

### Improved serialization of JSON objects

Before this release, we serialized JSON objects with a `NON_DEFAULT` strategy, meaning that only properties without default values were included in the serialized JSON document. This was done to save space in the database and optimize network bandwidth. However, this wasn't user-friendly. Kestra 0.17.0 [changed](https://github.com/kestra-io/kestra/pull/2358#issuecomment-2110307817) the serialization strategy to improve handling of null values and empty JSON objects.

Let's look at an example to make it more concrete:

```yaml
id: my_flow
namespace: dev

inputs:
  - id: my_string
    type: STRING
    defaults: null
    required: false

tasks:
  - id: print_input
    type: io.kestra.core.tasks.log.Log
    message: "{{ inputs.my_string }}" # workaround until 0.17.0: "{{ inputs.my_string ?? null }}"
```

Running the above workflow in Kestra < 0.17.0 would result in the following error:

```
Missing variable: 'inputs' on '{{ inputs.my_string }}' at line 1
Root attribute [inputs] does not exist or can not be accessed and strict variables is set to true. ({{ inputs.my_string }}:1)
```

The `my_string` input was not serialized due to the `NON_DEFAULT` strategy. In Kestra 0.17.0, the expression `{{ inputs.my_string }}` will no longer generate an error and will resolve to `null`, even without passing a default value:

```yaml
id: my_flow
namespace: dev

inputs:
  - id: my_string
    type: STRING
    required: false

tasks:
  - id: print_input
    type: io.kestra.plugin.core.log.Log
    message: "{{ inputs.my_string }}"
```

::alert{type="info"}
Note that the type of the `Log` task has been changed from `io.kestra.core.tasks.log.Log` to `io.kestra.plugin.core.log.Log` as part of the renaming process mentioned in the previous section.
::


## Enterprise Edition improvements üíº

### Default roles from the configuration

You can now configure a default role that will be assumed by new users joining your Kestra instance or tenant. To do that, you need to define the default role in the `security` section of your configuration file as follows:

```yaml
kestra:
  security:
    default-role:
      name: Editor
      description: Default Editor role
      permissions:
        FLOWS: ["CREATE", "READ", "UPDATE", "DELETE"]
        EXECUTIONS:
          - CREATE
          - READ
          - UPDATE
          - DELETE
```

The `permissions` property is a map with a `Permission` as a key (e.g. FLOWS, EXECUTIONS, NAMESPACES, SECRETS, etc.) and a list of allowed `Actions` (CREATE, READ, UPDATE, DELETE) as a value.

If the default role doesn't exist yet, it will be created automatically when you start Kestra. From then on, the default role will be assigned to new users joining your Kestra instance or tenant.

### Customizable tenant dropdown

You can now customize the tenant dropdown with a custom logo. This is especially useful if you're running a multi-tenant Kestra instance with one tenant per customer, company or environment.

To upload a custom logo, go to the `Tenants` page and navigate to the Tenant for which you want to add a new icon. Click on the `Edit` button and upload the logo in the `Logo` field.

![logo_upload](/blogs/2024-06-04-release-0-17/logo_upload.png)

Here is how it looks like on the Cluster Dashboard page:

![logo_display](/blogs/2024-06-04-release-0-17/logo_display.png)

### Allowed namespaces

We've added a new feature that allows you to explicitly declare which namespaces are allowed to trigger flows and other resources for any given namespace.

When you navigate to any Namespace and go to the `Edit` tab, you can explicitly configure which namespaces are allowed to access it. By default, all namespaces are allowed.

![allowed-namespaces](/docs/enterprise/allowed-namespaces.png)

However, you can restrict that access if you want only specific namespaces (or no namespace at all) to trigger its corresponding resources.

::alert{type="info"}
Check the [Allowed Namespaces](../docs/06.enterprise/allowed-namespaces.md) documentation for more details.
::


## Plugins improvements üîå

Apart from many Real-time Triggers, we've made several improvements to our plugins, including:
- The Debezium plugin has been [upgraded](https://github.com/kestra-io/plugin-debezium/issues/51) to be compatible with Debezium 2.x
- We've added a new MySQL [BatchInsert](https://github.com/kestra-io/plugin-jdbc/pull/293) task that allows you to insert multiple records into a MySQL database in a single transaction
- We've improved the output of [Downloads tasks](https://github.com/kestra-io/plugin-aws/issues/396) to make it easier to pass data between Downloads and Script tasks. Here is an example showing the new improved way of passing downloaded files to the `Script` task:

```yaml
id: process_files
namespace: dev

tasks:
  - id: download
    type: io.kestra.plugin.aws.s3.Downloads
    accessKeyId: abc123
    secretKeyId: xyz987
    region: us-east-1
    bucket: kestra-us
    prefix: sales/
    action: NONE

  - id: transform
    inputFiles: "{{ outputs.download.objects }}"
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - ls -R .
```

---

## Task runner improvements üèÉ

Task runners, introduced in Kestra 0.16.0, have been further improved in Kestra 0.17.0. Here are some of the enhancements:
- When an execution is manually killed by the user, the task runner infrastructure is now [automatically terminated](https://github.com/kestra-io/kestra/issues/3700#issuecomment-2109898018) to avoid unnecessary costs.
- We no longer create a new job upon resubmitting a task with Google Batch task runner. Instead, we now [reuse the existing job](https://github.com/kestra-io/plugin-gcp/issues/370).
- We now ensure that the `timeout` property defined in a Kestra task is propagated to a timeout of a cloud container (AWS/Azure/Google Batch Script Runners) [issue](https://github.com/kestra-io/kestra/issues/3461).

---

## Deprecations üßπ

We've deprecated [LocalFiles](https://github.com/kestra-io/kestra/issues/3728) and [outputDir](https://github.com/kestra-io/kestra/issues/3492) in Kestra 0.17.0. Here is why:

1. **outputDir**: the `{{ outputDir }}` expression has been deprecated due to overlapping functionality available through the `outputFiles` property which is more flexible.
2. **LocalFiles**: the `LocalFiles` feature was initially introduced to allow injecting additional files into the script task's `WorkingDirectory`. However, this feature was confusing as there is nothing _local_ about these files, and with the introduction of `inputFiles` to the `WorkingDirectory`, it became redundant. We recommend using the `inputFiles` property instead of `LocalFiles` to inject files into the script task's `WorkingDirectory`. The example below demonstrates how to do that:

```yaml
id: apiJSONtoMongoDB
namespace: dev

tasks:
- id: wdir
  type: io.kestra.plugin.core.flow.WorkingDirectory
  outputFiles:
    - output.json
  inputFiles:
    query.sql: |
      SELECT sum(total) as total, avg(quantity) as avg_quantity
      FROM sales;
  tasks:
    - id: inlineScript
      type: io.kestra.plugin.scripts.python.Script
      taskRunner:
        type: io.kestra.plugin.scripts.runner.docker.Docker
      containerImage: python:3.11-slim
      beforeCommands:
        - pip install requests kestra > /dev/null
      warningOnStdErr: false
      script: |
        import requests
        import json
        from kestra import Kestra

        with open('query.sql', 'r') as input_file:
            sql = input_file.read()

        response = requests.get('https://api.github.com')
        data = response.json()

        with open('output.json', 'w') as output_file:
            json.dump(data, output_file)

        Kestra.outputs({'receivedSQL': sql, 'status': response.status_code})

- id: loadToMongoDB
  type: io.kestra.plugin.mongodb.Load
  connection:
    uri: mongodb://host.docker.internal:27017/
  database: local
  collection: github
  from: "{{ outputs.wdir.uris['output.json'] }}"
```

---

## Next steps

This post covered new features and enhancements added in Kestra 0.17.0. Which of them are your favorites? What should we add next? Your feedback is always appreciated.

If you have any questions, reach out via [Slack](https://kestra.io/slack) or open [a GitHub issue](https://github.com/kestra-io/kestra).

If you like the project, give us [a GitHub star](https://github.com/kestra-io/kestra) and join [the community](https://kestra.io/slack).

