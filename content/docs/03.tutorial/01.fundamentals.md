---
title: Fundamentals
icon: /docs/icons/tutorial.svg
---

Start by building a simple Hello World flow.

:::alert{type="info"}
To install Kestra, follow the [Quickstart Guide](../01.quickstart/index.md) or check the detailed [Installation Guide](../02.installation/index.md).
:::

<div class=video-container>
  <iframe src="https://www.youtube.com/embed/6kV6OqadU90?si=hmEcf3dZGOm8xIV3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Flows

[Flows](../05.workflow-components/01.flow.md) are defined in a declarative YAML syntax to keep the orchestration code portable and language-agnostic.

Each flow consists of three required components: `id`, `namespace`, and `tasks`.
1. `id` is the unique identifier of the flow.
2. `namespace` separates projects, teams, and environments.
3. `tasks` is a list of tasks executed in order.

Here are those three components in a YAML file:

```yaml
id: getting_started
namespace: company.team

tasks:
  - id: hello_world
    type: io.kestra.plugin.core.log.Log
    message: Hello World!
```

The `id` of a flow must be unique within its namespace. For example:
- ‚úÖ You **can** have a flow named `getting_started` in `company.team1` and another flow named `getting_started` in `company.team2`.
- ‚ùå You **cannot** have two flows named `getting_started` in `company.team` at the same time.

The combination of `id` and `namespace` is the unique identifier for a flow.

### Namespaces

[Namespaces](../05.workflow-components/02.namespace.md) are used to group flows and provide structure. Keep in mind that a flow‚Äôs allocation to a namespace is immutable. Once a flow is created, you cannot change its namespace. If you need to change the namespace of a flow, create a new flow within the desired namespace and delete the old flow.


### Labels

To add another layer of organization, use [labels](../05.workflow-components/08.labels.md) to group flows with key‚Äìvalue pairs. In short, labels are customizable tags to simplify monitoring and filtering of flows and executions.


### Descriptions

You can optionally add a [description](../05.workflow-components/15.descriptions.md) property to document your flow's purpose or other useful information. The `description` is a string that supports **markdown** syntax. This markdown description is rendered and displayed in the UI.

:::alert{type="info"}
Not only flows can have a description. You can also add a `description` property to `tasks` and `triggers` to document all the components of your workflow.
:::

Here is the same flow as before, but with labels and descriptions:

```yaml
id: getting_started
namespace: company.team

description: |
  # Getting Started
  Let's `write` some **markdown** - [first flow](https://t.ly/Vemr0) üöÄ

labels:
  owner: rick.astley
  project: never-gonna-give-you-up

tasks:
  - id: hello_world
    type: io.kestra.plugin.core.log.Log
    message: Hello World!
    description: |
      ## About this task
      This task prints "Hello World!" to the logs.
```

Learn more about flows in the [Flows section](../05.workflow-components/01.flow.md).

---

## Tasks

[Tasks](../05.workflow-components/01.tasks/index.md) are atomic actions in your flows. You can design your tasks to be small and granular, such as fetching data from a REST API or running a self-contained Python script. However, tasks can also represent large and complex processes, like triggering containerized processes or long-running batch jobs (e.g., using dbt, Spark, AWS Batch, Azure Batch, etc.) and waiting for their completion.

### The order of task execution

Tasks are defined as a **list**. By default, all tasks in the list will be executed **sequentially** ‚Äî the second task will start as soon as the first one finishes successfully.

Kestra provides additional **customization** to run tasks **in parallel**, iterate (_sequentially or in parallel_) over a list of items, or allow **specific tasks to fail** without stopping the flow. These kinds of actions are called [`Flowable`](./05.flowable.md) tasks because they define the flow logic.

A task in Kestra must have an `id` and a `type`. Other properties depend on the task type. You can think of a task as a step in a flow that executes a specific action, such as running a Python or Node.js script in a Docker container or loading data from a database.

```yaml
tasks:
  - id: python
    type: io.kestra.plugin.scripts.python.Script
    containerImage: python:slim
    script: |
      print("Hello World!")
```

### Autocompletion

Kestra supports [hundreds of tasks](/plugins) integrating with various external systems. Use the shortcut `CTRL + SPACE` on Windows/Linux or `fn + control + SPACE` on macOS to trigger autocompletion to list available tasks or properties of a given task.

:::alert{type="info"}
If you want to comment out part of your code, use `CTRL + K + C` on Windows/Linux or `‚åò + fn + K + C` on macOS. To uncomment, use `CTRL + K + U` on Windows/Linux or `‚åò + fn + K + U` on macOS. All available keyboard shortcuts are listed in the code editor context menu.
:::

---

## Supported task types

Here are the supported task types.

### Core

Core tasks from the `io.kestra.plugin.core.flow` category control flow logic. Use them to run tasks in parallel or sequentially, branch conditionally, iterate over items, pause, or allow specific tasks to fail without stopping the execution.

### Scripts

Script tasks run scripts in Docker containers or local processes. You can run Python, Node.js, R, Julia, or other scripts, or execute commands in shell or PowerShell. See the [Script tasks](../16.scripts/index.md) page for details.

### Internal storage

Tasks from the `io.kestra.plugin.core.storage` category, along with [Outputs](../05.workflow-components/06.outputs.md), interact with internal storage. Kestra uses internal storage to pass data between tasks. You can treat internal storage like an S3 bucket, including your own private bucket.

This storage layer helps avoid connector sprawl. For example, the PostgreSQL plugin can extract data and load it into internal storage. Other tasks can then load that data into Snowflake, BigQuery, or Redshift‚Äîor process it with another plugin‚Äîwithout direct point-to-point connections.

### KV store

Internal storage is mainly used to pass data within a single flow execution. To pass data between executions, use the [KV Store](../06.concepts/05.kv-store.md). The `Set`, `Get`, and `Delete` tasks from `io.kestra.plugin.core.kv` persist data between executions (even across namespaces). For example, with [dbt](https://www.getdbt.com/), you can persist `manifest.json` between runs to implement a slim CI pattern.

### Plugins

Apart from core tasks, the [plugins library](/plugins) provides integrations for data ingestion, data transformation, databases, object stores, message queues, and more. You can also [create your own plugins](../plugin-developer-guide/index.md) to integrate with any system or language.

---

## Create and run your first flow

Now, let's create and run your first flow. On the left side of the screen, click on the **Flows** menu. Then, click on the **Create** button.

![Create flow](/docs/tutorial/fundamentals/create_button.png)

Paste the following code into the Flow editor:

```yaml
id: getting_started
namespace: company.team

tasks:
  - id: api
    type: io.kestra.plugin.core.http.Request
    uri: https://dummyjson.com/products
```

Then, hit the **Save** button.

![Create flow](/docs/tutorial/fundamentals/save_button.png)

This flow has a single task that fetches data from the [dummyjson](https://dummyjson.com/) API. Run it to see the output.

![New execution](/docs/tutorial/fundamentals/new_execution.png)

After execution, you‚Äôll be directed to the Gantt view to see the stages of your flow‚Äôs progress. In this simple example, we see the API request successfully execute. We'll continue adding more to our flow in the coming sections.

![gantt view](/docs/tutorial/fundamentals/gantt-view.png)
