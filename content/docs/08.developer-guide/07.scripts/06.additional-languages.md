---
title: Additional languages
icon: /docs/icons/dev.svg
---

Kestra is language agnostic. Use the Shell task to run any language.

Using `Commands`, you can run arbitrary commands in a Docker container. This means that you can use other languages as long as:
1. Their dependencies can be packaged into a Docker image
2. Their execution can be triggered from a `Shell` command line.

Below are a number of examples showing how you can do this with different programming languages.

For handling outputs and metrics, you can use the same approach that the `Shell` task uses by using `::{}::` syntax in log messages. Read more about it [here](07.outputs-metrics.md#shell).

## Go

Here is an example flow that runs a Go file inside of a container using a `golang` image:

```yaml
id: golang
namespace: company.team

tasks:
  - id: go
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: golang:latest
    namespaceFiles:
      enabled: true
    commands:
      - go run hello_world.go
```

The Go code is saved as a namespace file called `hello_world.go`:

```golang
package main

import "fmt"

func main() {
    fmt.Println("hello world")
}
```

When executed, we can see the print statement in the Kestra logs:

![golang_output](/docs/developer-guide/scripts/golang_output.png)

Check out the [full guide](../../15.how-to-guides/golang.md) which includes using [outputs and metrics](07.outputs-metrics.md).

## Rust

Here is an example flow using a Rust image created using the following [sample ETL project](https://github.com/kestra-io/examples/tree/main/examples/rust):

```yaml
id: rust_in_container
namespace: company.team

tasks:
  - id: rust
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: ghcr.io/kestra-io/rust:latest
    outputFiles:
      - "*.csv"
    commands:
      - etl
```

Once the container finishes execution, you'll be able to download all CSV files generated by the Rust container from the Outputs tab.

::alert{type="info"}
Note that the `ghcr.io/kestra-io/rust:latest` image is public, so you can directly use the example shown above and give it a try.
::

## Java

You can build [custom plugins](../06.plugins.md) in Java which will allow you to add custom tasks to your workflows. If you're looking to execute something simpler, you can use the `Shell` task with a Docker container.

Here is an example flow that runs a Java file inside of a container using a `eclipse-temurin` image:

```yaml
id: java
namespace: company.team

tasks:
  - id: java
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: eclipse-temurin:latest
    namespaceFiles:
      enabled: true
    commands:
      - javac HelloWorld.java
      - java HelloWorld
```

The Java code is saved as a namespace file called `HelloWorld.java`:

```java
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!"); 
    }
}
```

When executed, we can see the print statement in the Kestra logs:

![java_output](/docs/developer-guide/scripts/java_output.png)

When executed, we can see the print statement in the Kestra logs:

![php_output](/docs/developer-guide/scripts/php_output.png)

## C

Here is an example flow that runs a C file inside of a container using a `gcc` image:

```yaml
id: c
namespace: company.team

tasks:
  - id: c
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: gcc:latest
    namespaceFiles:
      enabled: true
    commands:
      - gcc hello_world.c
      - ./a.out
```

The C code is saved as a namespace file called `hello_world.c`:

```c
#include <stdio.h>

int main() {
   printf("Hello, World!");
   return 0;
}
```

When executed, we can see the print statement in the Kestra logs:

![c_output](/docs/developer-guide/scripts/c_output.png)

## C++

Here is an example flow that runs a C++ file inside of a container using a `gcc` image:

```yaml
id: cplusplus
namespace: company.team

tasks:
  - id: cpp
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: gcc:latest
    namespaceFiles:
      enabled: true
    commands:
      - g++ hello_world.cpp
      - ./a.out
```

The C++ code is saved as a namespace file called `hello_world.cpp`:

```cpp
#include <iostream>

int main() {
    std::cout << "Hello World!";
    return 0;
}
```

When executed, we can see the print statement in the Kestra logs:

![cpp_output](/docs/developer-guide/scripts/cpp_output.png)

## PHP

Here is an example flow that runs a PHP file inside of a container using a `php` image:

```yaml
id: php
namespace: company.team

tasks:
  - id: php
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: php:8.4-rc-alpine
    namespaceFiles:
      enabled: true
    commands:
      - php hello_world.php
```

The PHP code is saved as a namespace file called `hello_world.php`:

```php
<?php
echo "Hello, World!";
?>
```

## Perl

Here is an example flow that runs a Perl file inside of a container using a `perl` image:

```yaml
id: perl
namespace: company.team

tasks:
  - id: perl
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
    containerImage: perl:5.41.2
    namespaceFiles:
      enabled: true
    commands:
      - perl hello_world.pl
```

The Perl code is saved as a namespace file called `hello_world.pl`:

```perl
#!/usr/bin/perl
use warnings;
print("Hello, World!\n");
```

When executed, we can see the print statement in the Kestra logs:

![perl_output](/docs/developer-guide/scripts/perl_output.png)