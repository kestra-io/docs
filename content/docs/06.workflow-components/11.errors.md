---
title: Errors
icon: /docs/icons/flow.svg
---

Allow your flow to continue to operate despite errors.

There are multiple ways to handle errors in Kestra, to both help you identify them and allow flows to continue to operate despite errors.

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/VdVNqrL5aPI?si=4U749DR14cUV12P6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## `errors` Component

`errors` is a list of tasks set at the flow level that will be executed when an error occurs. You can add multiple tasks, and they will be executed sequentially. This is useful for sending alerts when errors occur.

The example below sends a flow-level failure alert via Slack using the [SlackIncomingWebhook](/plugins/plugin-notifications/tasks/slack/io.kestra.plugin.notifications.slack.slackincomingwebhook) task defined using the `errors` property.


```yaml file=public/examples/flows_errors_1.yaml
```

### Types of error handling

Two kinds of error handlers can be defined:
* **Global**: error handling global to a flow that must be at the root of the flow.
* **Local**: error handling local to a Flowable Task, will handle errors for the flowable task and its children.


#### Global Error Handler

This flow example has a single Bash task that fails immediately.
The global error handler will then be called so the `2nd` task will run.

```yaml
id: errors
namespace: company.team

tasks:
  - id: failed
    type: io.kestra.plugin.scripts.shell.Commands
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - exit 1
errors:
  - id: 2nd
    type: io.kestra.plugin.core.log.Log
    message: I'm failing {{task.id}}
    level: INFO
```


#### Local Error Handler

In this flow example, the error branch will be used **only** if a child of the task `t2` has an error. If the task `t1` failed, the error branch would not be used.

This can be useful to restrict error handling for a specific part of the flow and perform specific tasks like resource cleanup.

```yaml
id: errors
namespace: company.team

tasks:
  - id: parent-seq
    type: io.kestra.plugin.core.flow.Sequential
    tasks:
      - id: t1
        type: io.kestra.plugin.core.debug.Return
        format: "{{task.id}} > {{taskrun.startDate}}"
      - id: t2
        type: io.kestra.plugin.core.flow.Sequential
        tasks:
          - id: t2-t1
            type: io.kestra.plugin.scripts.shell.Commands
            taskRunner:
              type: io.kestra.plugin.core.runner.Process
            commands:
              - 'exit 1'
        errors:
          - id: error-t1
            type: io.kestra.plugin.core.debug.Return
            format: "Error Trigger ! {{task.id}}"
```

## `allowFailure` Property

When you execute a flow and one of its tasks fails, downstream tasks won't be executed. This may not always be desirable, especially for non-critical tasks. You can resolve this by adding the `allowFailure` property to the task, which will allow downstream tasks to continue despite the error. In this case, the execution will end in a `WARNING` state.

```yaml file=public/examples/flows_allow-failure.yml
```

Errors are special branches of a flow where you can define how to react to task failures (e.g. send an email, open a ticket, etc.).

