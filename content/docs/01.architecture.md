---
title: üèóÔ∏è Architecture
---

## Architecture diagram

The following diagram shows the main architecture components of a Kestra instance. The arrows visualize how the components interact with each other.

The diagram shows the architecture of both the **Open-Source** and the **Enterprise Edition** of Kestra.

![Kestra OSS Architecture](/docs/architecture/comparison.png "Kestra Architecture")

When comparing both diagrams, you can see that the main difference between the architecture of an **Open-Source** and an **Enterprise Edition** is the data layer (Database vs. Kafka and Elasticsearch). Note that it's also possible to use the Enterprise Edition with a Database backend for smaller deployments.

The **Worker** is the only component communicating with your private data sources to extract and transform data. The Worker also interacts with **Internal Storage** to persist intermediary data processing results and store the final task run outputs.

All components of the application layer (incl. Worker, Executor, Scheduler and Webserver) are **decoupled microservices** that communicate by exchanging messages with the Queue (Kafka or Database).

The **Webserver** communicates with both the (Database/Kafka) Queue and the (Database/Elasticsearch) Repository to serve data for Kestra UI and API.

The **data layer** is decoupled from the application logic layer and provides a separation between:
- storing your private data processing artifacts (**Internal Storage** ‚Äî think of it as an S3 bucket)
- storing execution metadata (Database/Kafka) **Queue**
- storing logs and data to serve Kestra UI and API (Elasticsearch/Database) **Repository**.

The Indexer, available only in the Enterprise Edition, indexes content from Kafka topics (_such as the flows and executions topics_) to the Elasticsearch repositories. Thanks to that separation between Queue and Repository, even if your Elasticsearch instance is down, your executions will continue to work by relying on the Kafka backend.

## Main components

Kestra has three internal components:
- The **Internal Storage** stores flow data like task outputs and flow inputs.
- The **Queue** is used for internal communication between Kestra server components.
- The **Repository** is used to store flows, templates, executions, logs, etc. The repository stores every internal object.

These internal components are provided on multiple implementations depending on your needs and deployment architecture. You may need to install additional plugins to use some implementations.

### Internal Storage

Kestra uses an **Internal Storage** to handle incoming and outgoing files of varying sizes. This notion is included in the heart of Kestra. Nowadays, storage availability is backed up by many file systems. We rely on these to guarantee the scalability of Kestra. The *Kestra Internal Storage* will store all the files generated by all tasks and transmit them between different tasks if needed.

By default, only the local storage is available. It uses a directory inside the host filesystem, so it is not scalable and not designed for production usage.

More implementations are available as plugins.

You can replace the local storage with one of the following storage implementations:
- [Storage Minio](https://github.com/kestra-io/storage-minio) for [Minio](https://min.io/), which is compatible with [AWS S3](https://aws.amazon.com/s3/) and all other *S3 Like* storage.
- [Storage GCS](https://github.com/kestra-io/storage-gcs) for [Google Cloud Storage](https://cloud.google.com/storage).
- [Storage Azure](https://github.com/kestra-io/storage-azure) for [Azure Blob Storage](https://azure.microsoft.com/en-us/services/storage/blobs/).

### Queue

The Queue, or more precisely, queues, are used internally for communication between the different Kestra server components. Kestra provides multiple queue types that must be used with their repository counterparts.

There are three types of queues:
- **In-Memory** that must be used with the In-Memory Repository.
- **Database** that must be used with the Database Repository.
- **Kafka** that must be used with the Elasticsearch Repository. **Only available in the [Enterprise Edition](/enterprise)**.

## Repository

The Repository, or more precisely, repositories, are the internal way to store data. Kestra provides multiple repository types that must be used with their queue counterparts.

There exist three types of repositories:
- **In-Memory** that must be used with the In-Memory Queue.
- **Database** that must be used with the Database Queue.
- **Elasticsearch** that must be used with the Kafka Queue. **Only available in the [Enterprise Edition](/enterprise)**.

## Server components

Kestra consists of multiple server components that can be scaled independently.
Each server component interacts with the Kestra internal components (internal storage, queues, and repositories).

### Executor

The **Executor** handles all executions and [flowable tasks](./05.developer-guide/02.tasks.md#flowable-tasks). The only goal of the Executor is to receive created executions and look for the next tasks to run. There is no heavy computation required (and no capacity for it) for this server component.

The Executor also handles special execution cases:
- [Listeners](./05.developer-guide/13.listeners.md)
- [Flow Triggers](./05.developer-guide/08.triggers/02.flow.md)
- [Templates](./05.developer-guide/09.templates.md)

You can scale Executors as necessary, but as no heavy computations are done in the Executor, this server component only requires little resources (unless you have a very high rate of executions).


### Worker

All tasks and polling triggers are executed by a **Worker**. A Worker receives and processes tasks from the Executor and polling triggers from the Scheduler. Given that tasks and polling triggers can be virtually anything (heavy computations, simple API calls, etc.), the Worker is essentially a Thread Pool where you can configure the number of threads you need.

You can scale Workers as necessary and have many instances on multiple servers, each with its own Thread Pool.

As the worker executes the tasks and the polling triggers, it needs access to any external services they use (database, REST services, message broker, etc.). Workers are the only server components that need access to external services.

#### Worker Group (EE)

::alert{type="warning"}
This is an [Enterprise Edition](https://kestra.io/enterprise) feature.
::

A Worker Group is a set of workers that can be targeted specifically for a task execution or a polling trigger evaluation. For this, the task or the polling trigger must define the `workerGroup.key` property with the key of the worker group to target. A default worker group can also be configured at the namespace level.

If the `workerGroup.key` property is not provided, all tasks and polling triggers are executed on the default worker group. That default worker group doesn't have a dedicated key.

Here are common use cases in which Worker Groups can be beneficial:
- Execute tasks and polling triggers on specific compute instances (e.g., a VM with a GPU and preconfigured CUDA drivers).
- Execute tasks and polling triggers on a worker with a specific Operating System (e.g., a Windows server).
- Restrict backend access to a set of workers (firewall rules, private networks, etc.).
- Execute tasks and polling triggers close to a remote backend (region selection).

::alert{type="warning"}
Even if you are using worker groups, we strongly recommend having at least one worker in the default worker group, as there is no way to enforce that all tasks and polling triggers have a `workerGroup.key` property set.
::

There is currently no way to validate whether a worker group exists before using it in a task or polling trigger. If a task or a polling trigger defines a worker group that doesn't exist, it will wait forever, leaving the flow's Execution stuck in a pending state.

A worker is part of a worker group if it is started with `--worker-group workerGroupKey`.

### Scheduler

The **Scheduler** will handle most of the [Triggers](./05.developer-guide/08.triggers/index.md) except the [Flow Triggers](./05.developer-guide/08.triggers/02.flow.md) which are handled by the Executor. It will continuously watch all the triggers and, if all conditions are met, will start an execution of the flow (submit the flow to the Executor).

In the case of polling triggers, the Scheduler will decide (based on the configured evaluation interval) whether to execute the flow. If the polling trigger conditions are met, the Scheduler will send the execution, along with the trigger metadata, to the Worker for execution.

Note that polling triggers cannot be evaluated concurrently. They also can't be reevaluated i.e. if the execution of a flow, which started as a result of the same trigger, is already in a Running state, the next execution will not be started until the previous one finishes.

Internally, the Scheduler will keep checking every second whether some trigger must be evaluated.

::alert{type="warning"}
By default, Kestra will handle all dates based on your system timezone. You can change the timezone with [JVM options](./09.administrator-guide/01.configuration/05.others.md#jvm-configuration).
::

### Indexer

The **Indexer** is an optional component only needed when using Kafka and Elasticsearch. It will watch for many Kafka topics (like flows and executions) and will index their content to Elasticsearch [Repositories](#the-repository).

### Webserver

The **Webserver** offers two main modules in the same component:
- **API**: All the [APIs](./12.api-guide/api-oss-guide.md) that allow triggering executions for any system, and interacting with Kestra.
- **UI**: The [User Interface](./04.user-interface-guide/index.md) (UI) is also served by the Webserver.

The Webserver interacts mostly with the Repository to deliver a rich API/UI. It also interacts with the Queue to trigger new executions, follow executions in real-time, etc.


::alert{type="info"}
Each server component (other than the Scheduler) can continue to work as long as the Queue is up and running. The Repository is only used to help provide our rich Webserver UI, and even if the Repository is down, workloads can continue to process on Kestra.
::

## Plugins

Kestra's core is not able to handle many task types by itself. We have therefore, included a [Plugins](../plugins) system that allows developing as many task types as you need.
A wide range of plugins is already available, and many more will be delivered by the Kestra team!

Plugins are also used to provide different implementations for Kestra's internal components like its Internal Storage.

## Deployment architecture

Kestra is a Java application that is provided as an executable. You have many deployments options:
- [Docker](./09.administrator-guide/02.deployment/01.docker.md)
- [Kubernetes](./09.administrator-guide/02.deployment/02.kubernetes.md)
- [Manual deployment](./09.administrator-guide/02.deployment/03.manual.md)

At its heart, Kestra has a plugin system allowing you to choose the dependency type that fits your needs.

You can find three example deployment architectures below.

### Small-sized deployment

![Kestra Standalone Architecture](/docs/architecture/archi-diagram-small.jpg "Kestra Standalone Architecture")

For a small-sized deployment, you can use Kestra standalone server, an all-in-one server component that allows running all Kestra server components in a single process. This deployment architecture has no scaling capability.

In this case, a database is the only dependency. This allows running Kestra with a minimal stack to maintain. We have, for now, three databases available:
- PostgreSQL
- MySQL
- H2

Database configuration options are available [here](./09.administrator-guide/01.configuration/01.databases.md).


### Medium-sized deployment

![Kestra Architecture](/docs/architecture/archi-diagram-medium-sized-deployement.jpg "Kestra Architecture")

For a medium-sized deployment, where high availability is not a strict requirement, you can use a database (Postgres or MySQL) as the only dependency. This allows running Kestra with a minimal stack to maintain. We have, for now, two databases available for this kind of architecture, as H2 is not a good fit when running distributed components:
- PostgreSQL
- MySQL

All server components will communicate through the database.

::alert{type="warning"}
When using a database, you can't scale the replica count for the scheduler, and you must have only **one** instance of it for the whole cluster.
::

Database configuration options are available [here](./09.administrator-guide/01.configuration/01.databases.md).

In this deployment mode, unless all components run on the same host, you must use a distributed storage implementation like Google Cloud Storage, AWS S3, or Azure Blob Storage.

### High-availability deployment

![Kestra High Availability Architecture](/docs/architecture/archi-diagram.jpg "Kestra High Availability Architecture")

To support higher throughput, and full horizontal and vertical scaling of the Kestra cluster, we can replace the database with Kafka and Elasticsearch. In this case, all the server components can be scaled without any single point of failure.

Kafka and Elasticsearch are available only in the **[Enterprise Edition](/enterprise)**.

In this deployment mode, unless all components run on the same host, you must use a distributed storage implementation like Google Cloud Storage, AWS S3, or Azure Blob Storage.

#### Kafka

[Kafka](https://kafka.apache.org/) is Kestra's primary dependency in high availability mode. Each of the most important server components in the deployment must have a Kafka instance up and running. Kafka allows Kestra to be a highly scalable solution.

Kafka configuration options are available [here](./09.administrator-guide/01.configuration/03.enterprise-edition/kafka.md).

##### Kafka Executor

With Kafka, the Executor is a heavy [Kafka Stream](https://kafka.apache.org/documentation/streams/) application. The Executor processes all events from Kafka in the right order, keeps an internal state of the execution, and merges task run results from the Worker.
It also detects dead Workers and resubmits the tasks run by a dead Worker.

As the Executor is a Kafka Stream, it can be scaled as needed (within the limits of partitions count on Kafka). Still, as no heavy computations are done in the Executor, this server component only requires a few resources (unless you have a very high rate of executions).

##### Kafka Worker

With Kafka, the Worker is a [Kafka Consumer](https://kafka.apache.org/documentation/#consumerapi) that will process any Task Run submitted to it. Workers will receive all tasks and dispatch them internally in their Thread Pool.

It can be scaled as needed (within the limits of partitions count on Kafka) and have many instances on multiple servers, each with its own Thread Pool.

With Kafka, if a Worker is dead, the Executor will detect it and resubmit their current task run to another Worker.

#### Elasticsearch
[Elasticsearch](https://www.elastic.co/) is Kestra's User Interface database in high availability mode, allowing the display, search, and aggregation of all Kestra's data (Flows, Executions, etc.). Elasticsearch is only used by the Webserver (API and UI).

Elasticsearch configuration options are available [here](./09.administrator-guide/01.configuration/03.enterprise-edition/elasticsearch.md).

## Multi-tenancy

Multi-tenancy is a software architecture in which a single instance of software serves multiple tenants. You can think of it as running multiple virtual instances in a single physical instance.

Multi-tenancy is available only in the **[Enterprise Edition](/enterprise)**.

Multi-tenancy allows you to manage **multiple environments** (e.g., dev, staging, prod) in a single Kestra instance. You can also use it to **separate resources** between business units, teams, or customers.

By default, multi-tenancy is disabled. See the [multi-tenancy section](./09.administrator-guide/01.configuration/03.enterprise-edition/multi-tenancy.md) of the Administrator Guide on how to configure it.

When multi-tenancy is enabled, all resources (such as flows, triggers, executions, RBAC, and more) are isolated by the tenant. This means that you can have a flow with the same identifier and the same namespace in multiple tenants at the same time.

Data stored inside the internal storage is also isolated by tenants.

Multi-tenancy functionality is not visible to end-users from the UI except for the tenant selection dropdown menu. That dropdown menu lists all tenants a user has access to, allowing users to switch between tenants easily. Each UI page will also include the tenant ID in the URL e.g. `https://demo.kestra.io/ui/yourTenantId/executions/namespace/flow/executionId`.

![Tenants selection dropdown](/docs/architecture/tenants-select.png "Tenants selection dropdown")

The API URLs will also change to include the tenant identifier.
For example, the URL of the API operation to list flows of the `products` namespace is `/api/v1/flows/products` when multi-tenancy is not enabled, and becomes `/api/v1/production/flows/products` for the `production` tenant when multi-tenancy is enabled. You can check the [Enterprise Edition API Guide](./12.api-guide/api-ee-guide.md) for more information.

Tenants must be created upfront, and a user needs to be granted access to use a specific tenant.