---
title: Moving from Development to Production
icon: /docs/icons/best-practices.svg
---

Common patterns for deploying flows from development to production environments.

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/iM4mjIEsxMY?si=zJtwEyGUmvclfXEU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Development environment

A best practice with Kestra is to maintain a dedicated **development instance** where users can create and test flows safely. This environment acts as a sandbox, allowing experimentation without impacting production or critical business operations.

You can set up a development environment in one of the following ways:
- Install Kestra locally using [Docker Compose](../02.installation/03.docker-compose.md)
- Deploy Kestra on a [Kubernetes cluster](../02.installation/03.kubernetes.md) accessible to users and isolated from production workloads

## Production environment

The production instance should be secured and tightly controlled, as it runs critical workflows that directly impact end users.  

A common best practice is to **limit access** to production systems. Two areas should be considered:

- User access  
- Flow deployments  

### User access

In **Kestra Enterprise**, user management is streamlined through [RBAC](../06.enterprise/03.auth/rbac.md) and [SSO](../06.enterprise/03.auth/sso/index.md).  
Administrators can define fine-grained access using role policies such as *Admin* or *Viewer*, ensuring proper access control across all resources. Learn more in the [Enterprise documentation](../06.enterprise/index.md).

For open-source users, it’s recommended to run a **restricted production instance**, accessible only to administrators and your [CI/CD system](../version-control-cicd/cicd/index.md).

### Flow deployments

Kestra supports several deployment strategies:
- [Via the UI](../08.ui/01.flows.md)
- [Git synchronization](../version-control-cicd/04.git.md)
- [CI/CD pipelines](../version-control-cicd/cicd/index.md)
- [Terraform](../13.terraform/index.md)
- [API](../api-reference/index.md)

Choose a method that aligns with your organization’s existing deployment processes.

A common approach is to move flows from development to production using a **version control system** (such as Git) combined with **CI/CD automation**.

In this pattern, developers commit flow changes to Git. Once the pull request is approved, the CI/CD system deploys the updated flows to the production instance.

Flows can be committed to Git using:
- Manual export or copy-paste from the UI
- The [`git.PushFlows` task](/plugins/plugin-git/io.kestra.plugin.git.pushflows)

CI/CD deployment to production can be automated with:
- GitHub Actions, GitLab CI/CD, Jenkins, or Azure DevOps
- Terraform
- The Kestra CLI

For more details on CI/CD automation, refer to the [CI/CD guide](../version-control-cicd/cicd/index.md).

---

## Git example

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/02bFAu-rpxU?si=bzj_Gs_mxxocdhd2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

You can use the [`git.SyncFlows` task](/plugins/plugin-git/io.kestra.plugin.git.syncflows) together with a [trigger](../04.workflow-components/07.triggers/index.md) to automatically pull flows from the `main` branch of your Git repository.  

This enables Kestra to manage the synchronization process directly, minimizing the need for external tools.

You can schedule synchronization using:
- A [Schedule trigger](../04.workflow-components/07.triggers/01.schedule-trigger.md) to pull flows at regular intervals (e.g., nightly)
- A [Webhook trigger](../04.workflow-components/07.triggers/03.webhook-trigger.md) to pull updates whenever new commits are pushed to `main`

See the [dedicated SyncFlows guide](../15.how-to-guides/syncflows.md) for details.

To push flows from development to Git, use the [`git.PushFlows` task](/plugins/plugin-git/io.kestra.plugin.git.pushflows).  
This ensures flows are validated before being saved—Kestra will reject invalid flows automatically.

You can also automate pull requests with the [`create.Pulls` task](/plugins/github/tasks/io.kestra.plugin.github.pulls.create), which creates a PR to `main` for review before deploying to production.

:::alert{type="info"}
While Kestra validates flow syntax, it does not detect logical or runtime errors. Always test flows thoroughly before promoting them to production.
:::

---

## CI/CD example

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/4MqtD9VtGVs?si=6yuJkPkq29SzKy_r" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

CI/CD pipelines can automatically deploy flows from Git to your Kestra production instance when changes are merged into the `main` branch.

For GitHub, Kestra provides an official [Deploy Action](../version-control-cicd/cicd/01.github-action.md#kestra-actions) that uses the Kestra Server CLI behind the scenes to perform deployments.  
You can pair this with the [Validate Action](../version-control-cicd/cicd/01.github-action.md#kestra-actions), which checks that flows are valid before merging.

By enforcing required status checks on pull requests, you can prevent invalid flows from being merged and deployed to production.

:::alert{type="info"}
**Note:** If a flow contains invalid syntax, the **Deploy Action** will fail.
:::
