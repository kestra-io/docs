---
title: Assets
icon: /docs/icons/admin.svg
editions: ["EE", "Cloud"]
version: ">= 1.2.0"
---

Track and manage the resources your workflows create and use.


## Overview

Assets keeps a live inventory of resources that your workflows interact with. These resources can be database tables, virtual machines, files, or any external system you work with.

You create assets in two ways: automatically through task execution or manually from the Assets UI. Once created, you can view asset details, check which workflow runs created or modified them, and see how assets connect to each other across your workflows.

This feature enables:

- Shipping metadata to lineage providers (e.g., OpenLineage).
- Populating dropdowns or Pebble inputs with live assets (e.g., available VMs).
- Monitoring assets and their state.

## Asset definition

Define assets directly on any task using the `assets` property. Each task can declare input assets (resources it reads) and output assets (resources it creates or modifies).

Every asset includes these fields:

| Field | Description |
| --- | --- |
| `id` | unique within a tenant |
| `namespace` | each asset can be associated with a namespace for filtering and RBAC management |
| `type` | use predefined Kestra types like `io.kestra.core.models.assets.Table` or any custom string value |
| `displayName` | optional human-readable name |
| `description` | markdown-supported documentation |
| `metadata` | map of key-value for adding custom metadata to the given asset |



###  Examples

The example below describes the asset produced by the `create_trips_table` task. Since there are no input dependencies, only the `trips` output asset is defined:

```yaml
id: pipeline_with_assets
namespace: company.team

tasks:
  - id: create_trips_table
    type: io.kestra.plugin.jdbc.sqlite.Queries
    url: jdbc:sqlite:myfile.db
    outputDbFile: true
    sql: |
      CREATE TABLE IF NOT EXISTS trips (
          VendorID INTEGER,
          passenger_count INTEGER,
          trip_distance REAL
      );
      
      INSERT INTO trips (VendorID, passenger_count, trip_distance) VALUES
      (1, 1, 1.5),
      (1, 2, 2.3),
      (2, 1, 0.8),
      (2, 3, 3.1;
    assets:
      inputs: []
      outputs:
        - id: trips
          namespace: "{{ flow.namespace }}"
          type: io.kestra.core.models.assets.Table
          metadata:
            database: sqlite
            table: trips
```

The following example demonstrates a more complex data pipeline with both input and output assets, showing how assets enable dependency tracking across multiple layers:

```yaml
id: data_pipeline_assets
namespace: kestra.company.data

tasks:
  - id: create_staging_layer_asset
    type: io.kestra.plugin.jdbc.duckdb.Query
    sql: |
      CREATE TABLE IF NOT EXISTS trips AS
      select VendorID, passenger_count, trip_distance from sample_data.nyc.taxi limit 10;
    assets:
      inputs:
        - id: sample_data.nyc.taxi
      outputs:
          - id: trips
            namespace: "{{flow.namespace}}"
            type: io.kestra.core.models.assets.Table
            metadata:
              model_layer: staging

  - id: for_each
    type: io.kestra.plugin.core.flow.ForEach
    values:
      - passenger_count
      - trip_distance
    tasks:
      - id: create_mart_layer_asset
        type: io.kestra.plugin.jdbc.duckdb.Query
        sql: SELECT AVG({{taskrun.value}}) AS avg_{{taskrun.value}} FROM trips;
        assets:
          inputs:
              - id: trips
          outputs:
              - id: avg_{{taskrun.value}}
                type: io.kestra.core.models.assets.Table
                namespace: "{{flow.namespace}}"
                metadata:
                  model_layer: mart
pluginDefaults:
  - type: io.kestra.plugin.jdbc.duckdb
    values:
      url: "jdbc:duckdb:md:my_db?motherduck_token={{ secret('MOTHERDUCK_TOKEN') }}"
      fetchType: STORE
```

This workflow demonstrates several key asset concepts:

- **External Asset Reference** - The `sample_data.nyc.taxi` asset is referenced as an input, representing an external data source that exists outside of this workflow. This allows Kestra to track dependencies on resources managed elsewhere.

- **Staging Layer Creation** - The `trips` table is created and registered as an output asset with `model_layer: staging` metadata. This asset becomes available for other workflows to reference as an input.

- **Mart Layer Generation** - The `ForEach` task dynamically creates multiple mart layer assets (`avg_passenger_count` and `avg_trip_distance`) from the staging `trips` asset. Each mart table references `trips` as an input asset, establishing a clear dependency chain.

- **Automatic Dependency Graph** - Kestra automatically tracks that the mart tables depend on the `trips` staging table, which in turn depends on the external `sample_data.nyc.taxi` source. This dependency graph is visible in the Assets UI, showing complete data lineage from source to consumption.

- **Metadata for Organization** - The `model_layer` metadata tag (`staging` vs `mart`) enables filtering and categorization of assets by their role in the data pipeline, making it easier to discover and manage resources at different layers.


## Asset Identifier

An asset is uniquely identified by its `id` and the tenant (`tenantId`) where you create it. You can attach a namespace to an asset to improve filtering, and to restrict visibility so only users or groups with the appropriate RBAC can access the asset.

## Asset Type

Asset types fall into two categories:

- **Kestra-defined asset types**: These predefined types use the `io.kestra.core.models.assets` model and provide structured metadata fields specific to each asset type. In future iterations of the Assets feature, Kestra plugins will allow to automatically generate assets with these types and populate their metadata fields during task execution. For example, a database plugin could automatically create a `Table` asset with the system, database, and schema fields filled in based on the connection details.

The current Kestra-defined asset types are the following:

- `io.kestra.plugin.ee.assets.Dataset`
  - Represents a dataset asset managed by Kestra.
  - Metadata: `system`, `location`, `format`

- `io.kestra.plugin.ee.assets.File`
  - Represents a file asset, such as documents, logs, or other file-based outputs.
  - Metadata: `system`, `path`

- `io.kestra.plugin.ee.assets.Table`
  - Represents a database table asset with schema and data location metadata.
  - Metadata: `system`, `database`, `schema`

- `io.kestra.plugin.ee.assets.VM`
  - Represents a virtual machine asset, including attributes like IP address and provider.
  - Metadata: `provider`, `region`, `state`


- **Free-form asset types**: You can define asset types using any custom string value to represent asset categories that fit your organization's needs. This lets you create and manage your own asset taxonomies, giving you flexibility to describe resources that are not covered by Kestra's standard models. These assets require manual definition and will not be auto-generated by plugins.



## Populate dropdowns and app inputs

The `assets()` Pebble function allows you to query and retrieve assets dynamically in your workflows. This is particularly useful for populating dropdown inputs or dynamically selecting resources based on filters.

### Function signature

```
assets(type: string, namespace: string, metadata: map)
```

### Parameters

| Parameter | Type | Required | Description |
| --- | --- | --- | --- |
| `type` | string | No | Filter assets by type (e.g., `"io.kestra.core.models.assets.Table"`). If omitted, returns all assets. |
| `namespace` | string | No | Filter assets by namespace. |
| `metadata` | map | No | Filter assets by metadata key-value pairs (e.g., `{"key": "value"}`). |


### Return value

Returns an array of asset objects. Each asset object contains the following properties:
- `tenantId` - The tenant ID where the asset is created
- `namespace` - The namespace the asset belongs to
- `id` - The asset identifier
- `type` - The asset type
- `metadata` - Map of custom metadata key-value pairs
- `created` - ISO 8601 timestamp when the asset was created
- `updated` - ISO 8601 timestamp when the asset was last updated
- `deleted` - Boolean indicating if the asset has been deleted


### Examples

**Populate a multiselect dropdown with table assets:**

```yaml
id: select_assets
namespace: company.team

inputs:
  - id: assets
    type: MULTISELECT
    expression: '{{ assets(type="io.kestra.core.models.assets.Table") | jq(".[].id") }}'

tasks:
  - id: for_each
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{inputs.assets}}"
    tasks:
      - id: log
        type: io.kestra.plugin.core.log.Log
        message: "{{taskrun.value}}"
```

**Filter assets by namespace:**

```yaml
inputs:
  - id: staging_tables
    type: MULTISELECT
    expression: '{{ assets(type="io.kestra.core.models.assets.Table", namespace="company.team") | jq(".[].id") }}'
```

**Filter assets by metadata:**

```yaml
inputs:
  - id: mart_tables
    type: MULTISELECT
    expression: '{{ assets(metadata={"model_layer": "mart"}) | jq(".[].id") }}'
```

**Get all assets and extract metadata:**

```yaml
id: list_assets_metadata
namespace: company.team
tasks:
  - id: list_all_assets
    type: io.kestra.plugin.core.log.Log
    message: "{{ assets() | jq('.[] | {id: .id, type: .type, metadata: .metadata}') }}"
```

## Export assets with AssetShipper

The `AssetShipper` task allows you to export asset metadata to external systems for lineage tracking, monitoring, or integration with data catalogs. You can ship assets to files or to lineage providers like OpenLineage.

### Export assets to file

Export asset metadata to a file in either ION or JSON format. This is useful for archiving, auditing, or importing into other systems.

```yaml
id: ship_asset_to_file
namespace: kestra.company.data

tasks:
  - id: export_assets
    type: io.kestra.plugin.ee.assets.AssetShipper
    assetExporters:
      - id: file_exporter
        type: io.kestra.plugin.ee.assets.FileAssetExporter
        format: ION
```

You can change the `format` property to `JSON` if you prefer a more widely-compatible format.

### Export assets to OpenLineage

Ship asset metadata to an OpenLineage-compatible lineage provider. This requires mapping Kestra asset fields to OpenLineage conventions.

```yaml
id: ship_asset_to_openlineage
namespace: kestra.company.data

tasks:
  - id: export_to_lineage
    type: io.kestra.plugin.ee.assets.AssetShipper
    assetExporters:
      - id: openlineage_exporter
        type: io.kestra.plugin.ee.openlineage.OpenLineageAssetExporter
        uri: http://host.docker.internal:5000
        mappings:
          io.kestra.plugin.ee.assets.Table:
            namespace: namespace
```

The `mappings` property defines how Kestra asset metadata fields map to OpenLineage dataset facets. Each asset type can have its own mapping configuration. For more information about OpenLineage dataset facets and available fields, see the [OpenLineage Dataset Facets documentation](https://openlineage.io/docs/spec/facets/dataset-facets/).