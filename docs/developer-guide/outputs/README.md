---
order: 4
---
# Outputs

Kestra's flows can produce outputs when processing tasks. Output data is stored in the execution flow context and can be handled and used by tasks executed after the output producer task.

You can use outputs everywhere [variables](/docs/developer-guide/variables/) are allowed, so they can be used as next task values for iteration or conditional processing, or even as extra output content.

## Using outputs

You can declare as many outputs as desired for any flow. Output context variables are stored following each task declaration.

Here is how to use an output between tasks into a flow:

```yaml
tasks:
- id: produce-output
  type: io.kestra.core.tasks.debugs.Return
  format: my output {{ execution.id }}
- id: use-output
  type: io.kestra.core.tasks.debugs.Echo
  format: This task display previous task output {{ outputs['produce-output'].value }}
```

In the example above the first task produces an output with the format of a YAML property. The output content is then used in the second task output template. Indeed, the `use-output` task uses the templating system <code v-pre>{{ outputs['produce-output'].value }}</code> to reference the previous task output. If you're not familiar with the syntax used here, please read [variables basic usage](/docs/developer-guide/variables/basic-usage.md).

Using this template context variable interpolates the bracket reference with the entire output generated by the first task.

::: tip note
The `.value` in the template bracket that uses another task's output content is a variable name that depends on which data is produced by the task. In our case, for the **Return** task, the `value` variable is filled with the output. It could be `bq_table` for another task implemented for BigQuery management by example. Have a look at each task documentation for specific information about what context variables are filled with output contents or use the `Outputs` tab of a flow execution from the UI.
:::

## Storage variables

Each task can store data into Kestra storage. This one output an URL that points to the storage location of the data.

This output variable can be used by other tasks to access the stored data.

For example, to access stored query results from a task that will transform them to a CSV file:

```yaml
tasks:
- id: output-from-query
  type: io.kestra.plugin.gcp.bigquery.Query
  sql: |
    SELECT * FROM `bigquery-public-data.wikipedia.pageviews_2023`
    WHERE DATE(datehour) = current_date()
    ORDER BY datehour desc, views desc
    LIMIT 10
  store: true
- id: write-to-csv
  type: io.kestra.plugin.serdes.csv.CsvWriter
  from: "{{outputs['output-from-query'].uri}}"
```

## Dynamic variables

#### Current value
You can access the current value with <code v-pre>{{ taskrun.value }}</code> like this:

```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: inner
        type: io.kestra.core.tasks.debugs.Return
        format: "{{task.id}} > {{taskrun.value}} > {{taskrun.startDate}}"
```

###  Specific outputs for dynamic tasks

Another more specific case for output management is the runtime-generated tasks output variable. This is the case for the **EachSequential** or **EachParallel** task, which produces other tasks dynamically, depending on its `value` attribute. In this case, it is possible to reach each iteration output individually using the following syntax:

```yaml
id: output-sample
namespace: io.kestra.tests

tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: sub
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ task.id }} > {{ taskrun.value }} > {{ taskrun.startDate }}"
    value: "[\"s1\", \"s2\", \"s3\"]"
  - id: use
    type: io.kestra.core.tasks.debugs.Return
    format: "Previous task produced output : {{ outputs.sub.s1.value }}"
```

Here the `outputs.sub.s1.value` reach the first `s1` task element.

#### Previous task lookup
It is also possible to locate a special task by its `value`:
```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: inner
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ task.id }}"
    value: "[\"value 1\", \"value 2\", \"value 3\"]"
  - id: end
    type: io.kestra.core.tasks.debugs.Return
    format: "{{ task.id }} > {{ outputs.inner['value 1'].value }}"
```
It uses the format `outputs.TASKID[VALUE].ATTRIBUTE`. The special bracket `[]` in  `.[VALUE].` enable special chars like space (and can be removed without any special characters)

#### Lookup in sibling tasks

Sometimes, it can be useful to access previous outputs on the current task tree, what is called sibling tasks.

If the task tree is static, for example when using the [Sequential](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.Sequential.md) task, you can use the <code v-pre>{{outputs.sibling.value}}</code> notation where `sibling`is the ID of the sibling task. 

If the task tree is dynamic, for example when using the [EachSequential](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.EachSequential.md) task, you need to use `sibling[taskrun.value]` to access the current tree task. `taskrun.value` is a special variable that holds the current value of the EachSequential task.

For example:
```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: first
        type: io.kestra.core.tasks.debugs.Return
        format: "{{task.id}}"
      - id: second
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ outputs.first[taskrun.value].value }}"
    value: "[\"value 1\", \"value 2\", \"value 3\"]"
  - id: end
    type: io.kestra.core.tasks.debugs.Return
    format: "{{task.id}} > {{outputs.second['value 1'].value}}"
```

When there are multiple levels of [EachSequential](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.EachSequential.md) tasks, you can use the `parents` variable to access the `taskrun.value` of the parent of the current EachSequential. For example, for two levels of EachSequential you can use `outputs.sibling[parents[0].taskrun.value][taskrun.value].value`.

The latter can become very complex when there are multiple parents (multiple imbricated EachSequential). For this, you can use the special [currentEachOutput](/docs/developer-guide/variables/function/currentEachOutput.md) function. No matter the number of parents, the following example will retrieve the right output: `currentEachOutput(outputs.sibling).value` thanks to this function.

:::warning
Accessing sibling task outputs is not possible on [Parallel](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.Parallel.md) or [EachParallel](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.EachParallel.md) as it runs tasks in parallel.
:::