---
order: 4
---
# Outputs

Kestra's flows can produce outputs when processing tasks. Output data is stored in execution flow context and can be handled and used by tasks executed after the output producer task.

You can use outputs everywhere [variables](/docs/developer-guide/variables/) are allowed, so they can be used as next task values for iteration or conditional processing, or even as extra output content.

## Using outputs

You can declare as many outputs as desired for any flow. Outputs context variables are stored following each task declaration.

Here how to use an output between tasks into a flow:

```yaml
tasks:
- id: produce-output
  type: io.kestra.core.tasks.debugs.Return
  format: my output {{ execution.id }}
- id: use-output
  type: io.kestra.core.tasks.debugs.Echo
  format: This task display previous task output {{ outputs['produce-output'].value }}
```

In the example above the first task produces an output with the format of a yaml property. The output content is then used in the second task output template. Indeed, the `use-output` task uses the templating system <code v-pre>{{ outputs['produce-output'].value }}</code> to reference the previous task output. If you're not familiar with the syntax used here, please read [variables basic usage](/docs/developer-guide/variables/basic-usage.md).

Using this template context variable interpolates the bracket reference with the entire output generated by the first task.

::: tip note
The `.value` in the template bracket that uses another task's output content is a variable name that depends on which data is produced by the task. In our case, for the **Return** task, the `value` variable is filled with the output. It could be `bq_table` for another task implemented for BigQuery management by example. Have a look at each task documentation for specific information about what context variables are filled with output contents or use the `Outputs` tab of a flow execution from the UI.
:::

## Storage variables

Each task can store data into Kestra storage. This one output an url that points to the storage location of the data.

This output variable can be used by other tasks to access the stored data.

For example, to access stored query results from a task that will transform them to a CSV file:

```yaml
tasks:
- id: output-from-query
  type: io.kestra.plugin.gcp.bigquery.Query
  sql: |
    SELECT * FROM `bigquery-public-data.wikipedia.pageviews_2023`
    WHERE DATE(datehour) = current_date()
    ORDER BY datehour desc, views desc
    LIMIT 10
  store: true
- id: write-to-csv
  type: io.kestra.plugin.serdes.csv.CsvWriter
  from: "{{outputs['output-from-query'].uri}}"
```

## Dynamic variables

#### Current value
You can access the current value with <code v-pre>{{ taskrun.value }}</code> like this:

```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: inner
        type: io.kestra.core.tasks.debugs.Return
        format: "{{task.id}} > {{taskrun.value}} > {{taskrun.startDate}}"
```

###  Specific outputs for dynamic tasks

Another more specific case for output management is the runtime generated tasks output variable. This is the case for the **EachSequential** or **EachParallel** task, which produces other tasks dynamically, depending on it's `value` property. In this case, it is possible to reach each iteration output individually using the following syntax:

```yaml
id: output-sample
namespace: io.kestra.tests

tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: sub
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ task.id }} > {{ taskrun.value }} > {{ taskrun.startDate }}"
    value: "[\"s1\", \"s2\", \"s3\"]"
  - id: use
    type: io.kestra.core.tasks.debugs.Return
    format: "Previous task produced output : {{ outputs.sub.s1.value }}"
```

Here the `outputs.sub.s1.value` reach the first `s1` task element.

#### Previous task lookup
It is also possible to locate a special task by its `value`:
```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: inner
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ task.id }}"
    value: "[\"value 1\", \"value 2\", \"value 3\"]"
  - id: end
    type: io.kestra.core.tasks.debugs.Return
    format: "{{ task.id }} > {{ outputs.inner['value 1'].value }}"
```
It uses the format `outputs.TASKID.[VALUE].PROPERTY`. The special bracket `[]` in  `.[VALUE].` enable special chars like space (and can be remove without any special characters)

#### Lookup in sibling tasks

Sometimes, it can be useful to access previous outputs on the current task tree, what is called sibling tasks. For example, on [EachSequential](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.EachSequential.md), you iterate for a list of value, perform the first task (Download a file for example), and
load the previous file to a database.

For this, you can pass the `taskrun.value` to outputs object:
```yaml
tasks:
  - id: each
    type: io.kestra.core.tasks.flows.EachSequential
    tasks:
      - id: first
        type: io.kestra.core.tasks.debugs.Return
        format: "{{task.id}}"
      - id: second
        type: io.kestra.core.tasks.debugs.Return
        format: "{{ outputs.first[taskrun.value].value }}"
    value: "[\"value 1\", \"value 2\", \"value 3\"]"
  - id: end
    type: io.kestra.core.tasks.debugs.Return
    format: "{{task.id}} > {{outputs.second['value 1'].value}}"
```

:::warning
Accessing sibling task outputs is not possible on [Parallel](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.Parallel.md) or [EachParallel](/plugins/core/tasks/flows/io.kestra.core.tasks.flows.EachParallel.md) as it runs tasks in parallel.
:::